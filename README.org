* Reference
  - [[https://norvig.com/lispy.html][(How to Write a (Lisp) Interpreter (in Python))]]
  - [[https://reasonml.github.io/api/Str.html][Module Str]]
  - [[https://stackoverflow.com/questions/48830710/how-do-i-declare-a-map-type-in-reason-ml][Reason Maps]]
* Goals
  - Define a function and call it
    #+BEGIN_SRC lisp
       (defn square (n)
         (* n n))

       (println (square 2))
    #+END_SRC
  - Create a repl executable
* Observations   
  - Not being able to print random data is super annoying
    - I wanted to check that my tokenize fn is working and the best I can do is check the length
  - It seemed good to flatten the expression type
    - Originally had ~type atom = Symbol | Number;~ too
    - It's a bit annoying that you can't have types without constructors
    - Like expression needs list wrapped in List
  - Can use a repl to see return values?
    - [[https://medium.com/@bobbypriambodo/starting-an-ocaml-app-project-using-dune-d4f74e291de8][People recomment utop]]
      - It sucks
    - the ocaml binary sucks too
  - Emacs editor support is pretty bad
  - This doesn't compile though I think it should
  #+BEGIN_SRC reason
    let argsToEnv = (env: environment, names: list(string), values: list(expression)): environment =>
      List.fold_left2(
      (env, name, value) => StringMap.add(env, name, value),
      StringMap.empty, names, values)
  #+END_SRC
* Repl
  - ~rtop~ seem to be the best option
    - But it can't find ~Str~
  - There are examples of compiling a custom toplevel with dune
    - But it can't ~#use~ reason files
    - And doesn't find modules that're loaded in with the run fn
  - rtop with require
    #+BEGIN_SRC bash
      rtop
      #require "str";
      #use "Lisp.re";
    #+END_SRC
  - Gave up and just wrote my own to string function
* Todo
**** TODO "There's no syntax for functions" is a good sign they shouldn't be part of the expression type
**** DONE Should be able to define and call a lambda immediately
     CLOSED: [2019-06-30 Sun 10:17]
**** DONE Implement let
     CLOSED: [2019-06-30 Sun 10:17]
**** Create ~evalExpression~ that always returns results wrapped in environment
***** Is aware of ~def~ and uses it to add things to the env
**** Change ~eval~ to be ~evalPureExpression~
**** Create ~eval~ that takes a list of expressions
***** Reduce over the expressions, passing the env to each new version, accumulating the results
* Talk
** Goal without macros
   #+BEGIN_SRC lisp
     (def square
       (fn (n)
         (* n n)))

     (println (square 4))

     ;; Output: 16
   #+END_SRC
** Goal
   #+BEGIN_SRC lisp
(defn square (n)
  (* n n))

(println (square 4))

;; Output: 16
   #+END_SRC
** Read
   #+BEGIN_SRC lisp
[List(Symbol("defn"), Symbol("Square"), List(Symbol("n")),
  List(Symbol("*"), Symbol("n"), Symbol("n"))),

List(Symbol("println"), List(Symbol("square"), Number(4)))]
   #+END_SRC
** Eval
*** Eventual
   #+BEGIN_SRC lisp
[Function(),
 Number(16)]

;; Output: 16
   #+END_SRC
*** Start with read
   #+BEGIN_SRC lisp
[List(Symbol("defn"), Symbol("Square"), List(Symbol("n")),
  List(Symbol("*"), Symbol("n"), Symbol("n"))),

List(Symbol("println"), List(Symbol("square"), Number(4)))]
   #+END_SRC
*** Start with read
   #+BEGIN_SRC lisp
[List(Symbol("defn"), Symbol("Square"), List(Symbol("n")),
  List(Symbol("*"), Symbol("n"), Symbol("n"))),

List(Symbol("println"), List(Symbol("square"), Number(4)))]
   #+END_SRC
*** Step 1
   #+BEGIN_SRC lisp
[List(Symbol("defn"), Symbol("Square"), List(Symbol("n")),
  List(Symbol("*"), Symbol("n"), Symbol("n"))),

List(Symbol("println"), List(Symbol("square"), Number(4)))]
   #+END_SRC
